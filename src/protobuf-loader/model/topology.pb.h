// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: topology.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_topology_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_topology_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_topology_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_topology_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_topology_2eproto;
namespace ns3_proto {
class AllNodes;
struct AllNodesDefaultTypeInternal;
extern AllNodesDefaultTypeInternal _AllNodes_default_instance_;
class GlobalConfig;
struct GlobalConfigDefaultTypeInternal;
extern GlobalConfigDefaultTypeInternal _GlobalConfig_default_instance_;
class HostGroup;
struct HostGroupDefaultTypeInternal;
extern HostGroupDefaultTypeInternal _HostGroup_default_instance_;
class HostPortConfig;
struct HostPortConfigDefaultTypeInternal;
extern HostPortConfigDefaultTypeInternal _HostPortConfig_default_instance_;
class Link;
struct LinkDefaultTypeInternal;
extern LinkDefaultTypeInternal _Link_default_instance_;
class PortQueueConfig;
struct PortQueueConfigDefaultTypeInternal;
extern PortQueueConfigDefaultTypeInternal _PortQueueConfig_default_instance_;
class SwitchGroup;
struct SwitchGroupDefaultTypeInternal;
extern SwitchGroupDefaultTypeInternal _SwitchGroup_default_instance_;
class SwitchMmuConfig;
struct SwitchMmuConfigDefaultTypeInternal;
extern SwitchMmuConfigDefaultTypeInternal _SwitchMmuConfig_default_instance_;
class SwitchPortConfig;
struct SwitchPortConfigDefaultTypeInternal;
extern SwitchPortConfigDefaultTypeInternal _SwitchPortConfig_default_instance_;
class Topology;
struct TopologyDefaultTypeInternal;
extern TopologyDefaultTypeInternal _Topology_default_instance_;
}  // namespace ns3_proto
PROTOBUF_NAMESPACE_OPEN
template<> ::ns3_proto::AllNodes* Arena::CreateMaybeMessage<::ns3_proto::AllNodes>(Arena*);
template<> ::ns3_proto::GlobalConfig* Arena::CreateMaybeMessage<::ns3_proto::GlobalConfig>(Arena*);
template<> ::ns3_proto::HostGroup* Arena::CreateMaybeMessage<::ns3_proto::HostGroup>(Arena*);
template<> ::ns3_proto::HostPortConfig* Arena::CreateMaybeMessage<::ns3_proto::HostPortConfig>(Arena*);
template<> ::ns3_proto::Link* Arena::CreateMaybeMessage<::ns3_proto::Link>(Arena*);
template<> ::ns3_proto::PortQueueConfig* Arena::CreateMaybeMessage<::ns3_proto::PortQueueConfig>(Arena*);
template<> ::ns3_proto::SwitchGroup* Arena::CreateMaybeMessage<::ns3_proto::SwitchGroup>(Arena*);
template<> ::ns3_proto::SwitchMmuConfig* Arena::CreateMaybeMessage<::ns3_proto::SwitchMmuConfig>(Arena*);
template<> ::ns3_proto::SwitchPortConfig* Arena::CreateMaybeMessage<::ns3_proto::SwitchPortConfig>(Arena*);
template<> ::ns3_proto::Topology* Arena::CreateMaybeMessage<::ns3_proto::Topology>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ns3_proto {

// ===================================================================

class GlobalConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ns3_proto.GlobalConfig) */ {
 public:
  inline GlobalConfig() : GlobalConfig(nullptr) {}
  ~GlobalConfig() override;
  explicit PROTOBUF_CONSTEXPR GlobalConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GlobalConfig(const GlobalConfig& from);
  GlobalConfig(GlobalConfig&& from) noexcept
    : GlobalConfig() {
    *this = ::std::move(from);
  }

  inline GlobalConfig& operator=(const GlobalConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline GlobalConfig& operator=(GlobalConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GlobalConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const GlobalConfig* internal_default_instance() {
    return reinterpret_cast<const GlobalConfig*>(
               &_GlobalConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GlobalConfig& a, GlobalConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(GlobalConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GlobalConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GlobalConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GlobalConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GlobalConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GlobalConfig& from) {
    GlobalConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GlobalConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ns3_proto.GlobalConfig";
  }
  protected:
  explicit GlobalConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRandomSeedFieldNumber = 1,
  };
  // optional uint32 randomSeed = 1;
  bool has_randomseed() const;
  private:
  bool _internal_has_randomseed() const;
  public:
  void clear_randomseed();
  uint32_t randomseed() const;
  void set_randomseed(uint32_t value);
  private:
  uint32_t _internal_randomseed() const;
  void _internal_set_randomseed(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ns3_proto.GlobalConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t randomseed_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_topology_2eproto;
};
// -------------------------------------------------------------------

class HostPortConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ns3_proto.HostPortConfig) */ {
 public:
  inline HostPortConfig() : HostPortConfig(nullptr) {}
  ~HostPortConfig() override;
  explicit PROTOBUF_CONSTEXPR HostPortConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HostPortConfig(const HostPortConfig& from);
  HostPortConfig(HostPortConfig&& from) noexcept
    : HostPortConfig() {
    *this = ::std::move(from);
  }

  inline HostPortConfig& operator=(const HostPortConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline HostPortConfig& operator=(HostPortConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HostPortConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const HostPortConfig* internal_default_instance() {
    return reinterpret_cast<const HostPortConfig*>(
               &_HostPortConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(HostPortConfig& a, HostPortConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(HostPortConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HostPortConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HostPortConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HostPortConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HostPortConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HostPortConfig& from) {
    HostPortConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HostPortConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ns3_proto.HostPortConfig";
  }
  protected:
  explicit HostPortConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPfcEnabledFieldNumber = 1,
  };
  // bool pfcEnabled = 1;
  void clear_pfcenabled();
  bool pfcenabled() const;
  void set_pfcenabled(bool value);
  private:
  bool _internal_pfcenabled() const;
  void _internal_set_pfcenabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ns3_proto.HostPortConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool pfcenabled_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_topology_2eproto;
};
// -------------------------------------------------------------------

class HostGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ns3_proto.HostGroup) */ {
 public:
  inline HostGroup() : HostGroup(nullptr) {}
  ~HostGroup() override;
  explicit PROTOBUF_CONSTEXPR HostGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HostGroup(const HostGroup& from);
  HostGroup(HostGroup&& from) noexcept
    : HostGroup() {
    *this = ::std::move(from);
  }

  inline HostGroup& operator=(const HostGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline HostGroup& operator=(HostGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HostGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const HostGroup* internal_default_instance() {
    return reinterpret_cast<const HostGroup*>(
               &_HostGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(HostGroup& a, HostGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(HostGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HostGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HostGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HostGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HostGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HostGroup& from) {
    HostGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HostGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ns3_proto.HostGroup";
  }
  protected:
  explicit HostGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortsFieldNumber = 3,
    kNodesNumFieldNumber = 1,
    kBaseIndexFieldNumber = 2,
  };
  // repeated .ns3_proto.HostPortConfig ports = 3;
  int ports_size() const;
  private:
  int _internal_ports_size() const;
  public:
  void clear_ports();
  ::ns3_proto::HostPortConfig* mutable_ports(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ns3_proto::HostPortConfig >*
      mutable_ports();
  private:
  const ::ns3_proto::HostPortConfig& _internal_ports(int index) const;
  ::ns3_proto::HostPortConfig* _internal_add_ports();
  public:
  const ::ns3_proto::HostPortConfig& ports(int index) const;
  ::ns3_proto::HostPortConfig* add_ports();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ns3_proto::HostPortConfig >&
      ports() const;

  // uint32 nodesNum = 1;
  void clear_nodesnum();
  uint32_t nodesnum() const;
  void set_nodesnum(uint32_t value);
  private:
  uint32_t _internal_nodesnum() const;
  void _internal_set_nodesnum(uint32_t value);
  public:

  // uint32 baseIndex = 2;
  void clear_baseindex();
  uint32_t baseindex() const;
  void set_baseindex(uint32_t value);
  private:
  uint32_t _internal_baseindex() const;
  void _internal_set_baseindex(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ns3_proto.HostGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ns3_proto::HostPortConfig > ports_;
    uint32_t nodesnum_;
    uint32_t baseindex_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_topology_2eproto;
};
// -------------------------------------------------------------------

class PortQueueConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ns3_proto.PortQueueConfig) */ {
 public:
  inline PortQueueConfig() : PortQueueConfig(nullptr) {}
  ~PortQueueConfig() override;
  explicit PROTOBUF_CONSTEXPR PortQueueConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PortQueueConfig(const PortQueueConfig& from);
  PortQueueConfig(PortQueueConfig&& from) noexcept
    : PortQueueConfig() {
    *this = ::std::move(from);
  }

  inline PortQueueConfig& operator=(const PortQueueConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortQueueConfig& operator=(PortQueueConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PortQueueConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const PortQueueConfig* internal_default_instance() {
    return reinterpret_cast<const PortQueueConfig*>(
               &_PortQueueConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PortQueueConfig& a, PortQueueConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(PortQueueConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortQueueConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PortQueueConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PortQueueConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PortQueueConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PortQueueConfig& from) {
    PortQueueConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PortQueueConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ns3_proto.PortQueueConfig";
  }
  protected:
  explicit PortQueueConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPfcReservedFieldNumber = 1,
    kPfcHeadroomFieldNumber = 2,
    kEcnKMinFieldNumber = 4,
    kEcnKMaxFieldNumber = 5,
    kEcnPMaxFieldNumber = 6,
  };
  // optional string pfcReserved = 1;
  bool has_pfcreserved() const;
  private:
  bool _internal_has_pfcreserved() const;
  public:
  void clear_pfcreserved();
  const std::string& pfcreserved() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pfcreserved(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pfcreserved();
  PROTOBUF_NODISCARD std::string* release_pfcreserved();
  void set_allocated_pfcreserved(std::string* pfcreserved);
  private:
  const std::string& _internal_pfcreserved() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pfcreserved(const std::string& value);
  std::string* _internal_mutable_pfcreserved();
  public:

  // optional string pfcHeadroom = 2;
  bool has_pfcheadroom() const;
  private:
  bool _internal_has_pfcheadroom() const;
  public:
  void clear_pfcheadroom();
  const std::string& pfcheadroom() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pfcheadroom(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pfcheadroom();
  PROTOBUF_NODISCARD std::string* release_pfcheadroom();
  void set_allocated_pfcheadroom(std::string* pfcheadroom);
  private:
  const std::string& _internal_pfcheadroom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pfcheadroom(const std::string& value);
  std::string* _internal_mutable_pfcheadroom();
  public:

  // optional string ecnKMin = 4;
  bool has_ecnkmin() const;
  private:
  bool _internal_has_ecnkmin() const;
  public:
  void clear_ecnkmin();
  const std::string& ecnkmin() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ecnkmin(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ecnkmin();
  PROTOBUF_NODISCARD std::string* release_ecnkmin();
  void set_allocated_ecnkmin(std::string* ecnkmin);
  private:
  const std::string& _internal_ecnkmin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ecnkmin(const std::string& value);
  std::string* _internal_mutable_ecnkmin();
  public:

  // optional string ecnKMax = 5;
  bool has_ecnkmax() const;
  private:
  bool _internal_has_ecnkmax() const;
  public:
  void clear_ecnkmax();
  const std::string& ecnkmax() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ecnkmax(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ecnkmax();
  PROTOBUF_NODISCARD std::string* release_ecnkmax();
  void set_allocated_ecnkmax(std::string* ecnkmax);
  private:
  const std::string& _internal_ecnkmax() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ecnkmax(const std::string& value);
  std::string* _internal_mutable_ecnkmax();
  public:

  // optional double ecnPMax = 6;
  bool has_ecnpmax() const;
  private:
  bool _internal_has_ecnpmax() const;
  public:
  void clear_ecnpmax();
  double ecnpmax() const;
  void set_ecnpmax(double value);
  private:
  double _internal_ecnpmax() const;
  void _internal_set_ecnpmax(double value);
  public:

  // @@protoc_insertion_point(class_scope:ns3_proto.PortQueueConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pfcreserved_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pfcheadroom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ecnkmin_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ecnkmax_;
    double ecnpmax_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_topology_2eproto;
};
// -------------------------------------------------------------------

class SwitchPortConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ns3_proto.SwitchPortConfig) */ {
 public:
  inline SwitchPortConfig() : SwitchPortConfig(nullptr) {}
  ~SwitchPortConfig() override;
  explicit PROTOBUF_CONSTEXPR SwitchPortConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SwitchPortConfig(const SwitchPortConfig& from);
  SwitchPortConfig(SwitchPortConfig&& from) noexcept
    : SwitchPortConfig() {
    *this = ::std::move(from);
  }

  inline SwitchPortConfig& operator=(const SwitchPortConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline SwitchPortConfig& operator=(SwitchPortConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SwitchPortConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const SwitchPortConfig* internal_default_instance() {
    return reinterpret_cast<const SwitchPortConfig*>(
               &_SwitchPortConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SwitchPortConfig& a, SwitchPortConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(SwitchPortConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SwitchPortConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SwitchPortConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SwitchPortConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SwitchPortConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SwitchPortConfig& from) {
    SwitchPortConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchPortConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ns3_proto.SwitchPortConfig";
  }
  protected:
  explicit SwitchPortConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQueuesFieldNumber = 4,
    kPfcEnabledFieldNumber = 1,
    kPfcPassThroughFieldNumber = 2,
    kEcnEnabledFieldNumber = 3,
  };
  // repeated .ns3_proto.PortQueueConfig queues = 4;
  int queues_size() const;
  private:
  int _internal_queues_size() const;
  public:
  void clear_queues();
  ::ns3_proto::PortQueueConfig* mutable_queues(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ns3_proto::PortQueueConfig >*
      mutable_queues();
  private:
  const ::ns3_proto::PortQueueConfig& _internal_queues(int index) const;
  ::ns3_proto::PortQueueConfig* _internal_add_queues();
  public:
  const ::ns3_proto::PortQueueConfig& queues(int index) const;
  ::ns3_proto::PortQueueConfig* add_queues();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ns3_proto::PortQueueConfig >&
      queues() const;

  // bool pfcEnabled = 1;
  void clear_pfcenabled();
  bool pfcenabled() const;
  void set_pfcenabled(bool value);
  private:
  bool _internal_pfcenabled() const;
  void _internal_set_pfcenabled(bool value);
  public:

  // optional bool pfcPassThrough = 2;
  bool has_pfcpassthrough() const;
  private:
  bool _internal_has_pfcpassthrough() const;
  public:
  void clear_pfcpassthrough();
  bool pfcpassthrough() const;
  void set_pfcpassthrough(bool value);
  private:
  bool _internal_pfcpassthrough() const;
  void _internal_set_pfcpassthrough(bool value);
  public:

  // bool ecnEnabled = 3;
  void clear_ecnenabled();
  bool ecnenabled() const;
  void set_ecnenabled(bool value);
  private:
  bool _internal_ecnenabled() const;
  void _internal_set_ecnenabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ns3_proto.SwitchPortConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ns3_proto::PortQueueConfig > queues_;
    bool pfcenabled_;
    bool pfcpassthrough_;
    bool ecnenabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_topology_2eproto;
};
// -------------------------------------------------------------------

class SwitchMmuConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ns3_proto.SwitchMmuConfig) */ {
 public:
  inline SwitchMmuConfig() : SwitchMmuConfig(nullptr) {}
  ~SwitchMmuConfig() override;
  explicit PROTOBUF_CONSTEXPR SwitchMmuConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SwitchMmuConfig(const SwitchMmuConfig& from);
  SwitchMmuConfig(SwitchMmuConfig&& from) noexcept
    : SwitchMmuConfig() {
    *this = ::std::move(from);
  }

  inline SwitchMmuConfig& operator=(const SwitchMmuConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline SwitchMmuConfig& operator=(SwitchMmuConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SwitchMmuConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const SwitchMmuConfig* internal_default_instance() {
    return reinterpret_cast<const SwitchMmuConfig*>(
               &_SwitchMmuConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SwitchMmuConfig& a, SwitchMmuConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(SwitchMmuConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SwitchMmuConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SwitchMmuConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SwitchMmuConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SwitchMmuConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SwitchMmuConfig& from) {
    SwitchMmuConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchMmuConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ns3_proto.SwitchMmuConfig";
  }
  protected:
  explicit SwitchMmuConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBufferSizeFieldNumber = 1,
    kPfcDynamicShiftFieldNumber = 2,
  };
  // string bufferSize = 1;
  void clear_buffersize();
  const std::string& buffersize() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_buffersize(ArgT0&& arg0, ArgT... args);
  std::string* mutable_buffersize();
  PROTOBUF_NODISCARD std::string* release_buffersize();
  void set_allocated_buffersize(std::string* buffersize);
  private:
  const std::string& _internal_buffersize() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buffersize(const std::string& value);
  std::string* _internal_mutable_buffersize();
  public:

  // optional uint32 pfcDynamicShift = 2;
  bool has_pfcdynamicshift() const;
  private:
  bool _internal_has_pfcdynamicshift() const;
  public:
  void clear_pfcdynamicshift();
  uint32_t pfcdynamicshift() const;
  void set_pfcdynamicshift(uint32_t value);
  private:
  uint32_t _internal_pfcdynamicshift() const;
  void _internal_set_pfcdynamicshift(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ns3_proto.SwitchMmuConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buffersize_;
    uint32_t pfcdynamicshift_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_topology_2eproto;
};
// -------------------------------------------------------------------

class SwitchGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ns3_proto.SwitchGroup) */ {
 public:
  inline SwitchGroup() : SwitchGroup(nullptr) {}
  ~SwitchGroup() override;
  explicit PROTOBUF_CONSTEXPR SwitchGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SwitchGroup(const SwitchGroup& from);
  SwitchGroup(SwitchGroup&& from) noexcept
    : SwitchGroup() {
    *this = ::std::move(from);
  }

  inline SwitchGroup& operator=(const SwitchGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline SwitchGroup& operator=(SwitchGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SwitchGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const SwitchGroup* internal_default_instance() {
    return reinterpret_cast<const SwitchGroup*>(
               &_SwitchGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SwitchGroup& a, SwitchGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(SwitchGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SwitchGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SwitchGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SwitchGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SwitchGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SwitchGroup& from) {
    SwitchGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ns3_proto.SwitchGroup";
  }
  protected:
  explicit SwitchGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortsFieldNumber = 5,
    kMmuFieldNumber = 3,
    kNodesNumFieldNumber = 1,
    kBaseIndexFieldNumber = 2,
    kQueueNumFieldNumber = 4,
  };
  // repeated .ns3_proto.SwitchPortConfig ports = 5;
  int ports_size() const;
  private:
  int _internal_ports_size() const;
  public:
  void clear_ports();
  ::ns3_proto::SwitchPortConfig* mutable_ports(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ns3_proto::SwitchPortConfig >*
      mutable_ports();
  private:
  const ::ns3_proto::SwitchPortConfig& _internal_ports(int index) const;
  ::ns3_proto::SwitchPortConfig* _internal_add_ports();
  public:
  const ::ns3_proto::SwitchPortConfig& ports(int index) const;
  ::ns3_proto::SwitchPortConfig* add_ports();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ns3_proto::SwitchPortConfig >&
      ports() const;

  // .ns3_proto.SwitchMmuConfig mmu = 3;
  bool has_mmu() const;
  private:
  bool _internal_has_mmu() const;
  public:
  void clear_mmu();
  const ::ns3_proto::SwitchMmuConfig& mmu() const;
  PROTOBUF_NODISCARD ::ns3_proto::SwitchMmuConfig* release_mmu();
  ::ns3_proto::SwitchMmuConfig* mutable_mmu();
  void set_allocated_mmu(::ns3_proto::SwitchMmuConfig* mmu);
  private:
  const ::ns3_proto::SwitchMmuConfig& _internal_mmu() const;
  ::ns3_proto::SwitchMmuConfig* _internal_mutable_mmu();
  public:
  void unsafe_arena_set_allocated_mmu(
      ::ns3_proto::SwitchMmuConfig* mmu);
  ::ns3_proto::SwitchMmuConfig* unsafe_arena_release_mmu();

  // uint32 nodesNum = 1;
  void clear_nodesnum();
  uint32_t nodesnum() const;
  void set_nodesnum(uint32_t value);
  private:
  uint32_t _internal_nodesnum() const;
  void _internal_set_nodesnum(uint32_t value);
  public:

  // uint32 baseIndex = 2;
  void clear_baseindex();
  uint32_t baseindex() const;
  void set_baseindex(uint32_t value);
  private:
  uint32_t _internal_baseindex() const;
  void _internal_set_baseindex(uint32_t value);
  public:

  // uint32 queueNum = 4;
  void clear_queuenum();
  uint32_t queuenum() const;
  void set_queuenum(uint32_t value);
  private:
  uint32_t _internal_queuenum() const;
  void _internal_set_queuenum(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ns3_proto.SwitchGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ns3_proto::SwitchPortConfig > ports_;
    ::ns3_proto::SwitchMmuConfig* mmu_;
    uint32_t nodesnum_;
    uint32_t baseindex_;
    uint32_t queuenum_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_topology_2eproto;
};
// -------------------------------------------------------------------

class AllNodes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ns3_proto.AllNodes) */ {
 public:
  inline AllNodes() : AllNodes(nullptr) {}
  ~AllNodes() override;
  explicit PROTOBUF_CONSTEXPR AllNodes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AllNodes(const AllNodes& from);
  AllNodes(AllNodes&& from) noexcept
    : AllNodes() {
    *this = ::std::move(from);
  }

  inline AllNodes& operator=(const AllNodes& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllNodes& operator=(AllNodes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllNodes& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllNodes* internal_default_instance() {
    return reinterpret_cast<const AllNodes*>(
               &_AllNodes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AllNodes& a, AllNodes& b) {
    a.Swap(&b);
  }
  inline void Swap(AllNodes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllNodes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllNodes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AllNodes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AllNodes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AllNodes& from) {
    AllNodes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllNodes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ns3_proto.AllNodes";
  }
  protected:
  explicit AllNodes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostGroupsFieldNumber = 2,
    kSwitchGroupsFieldNumber = 3,
    kNumFieldNumber = 1,
  };
  // repeated .ns3_proto.HostGroup hostGroups = 2;
  int hostgroups_size() const;
  private:
  int _internal_hostgroups_size() const;
  public:
  void clear_hostgroups();
  ::ns3_proto::HostGroup* mutable_hostgroups(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ns3_proto::HostGroup >*
      mutable_hostgroups();
  private:
  const ::ns3_proto::HostGroup& _internal_hostgroups(int index) const;
  ::ns3_proto::HostGroup* _internal_add_hostgroups();
  public:
  const ::ns3_proto::HostGroup& hostgroups(int index) const;
  ::ns3_proto::HostGroup* add_hostgroups();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ns3_proto::HostGroup >&
      hostgroups() const;

  // repeated .ns3_proto.SwitchGroup switchGroups = 3;
  int switchgroups_size() const;
  private:
  int _internal_switchgroups_size() const;
  public:
  void clear_switchgroups();
  ::ns3_proto::SwitchGroup* mutable_switchgroups(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ns3_proto::SwitchGroup >*
      mutable_switchgroups();
  private:
  const ::ns3_proto::SwitchGroup& _internal_switchgroups(int index) const;
  ::ns3_proto::SwitchGroup* _internal_add_switchgroups();
  public:
  const ::ns3_proto::SwitchGroup& switchgroups(int index) const;
  ::ns3_proto::SwitchGroup* add_switchgroups();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ns3_proto::SwitchGroup >&
      switchgroups() const;

  // uint32 num = 1;
  void clear_num();
  uint32_t num() const;
  void set_num(uint32_t value);
  private:
  uint32_t _internal_num() const;
  void _internal_set_num(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ns3_proto.AllNodes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ns3_proto::HostGroup > hostgroups_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ns3_proto::SwitchGroup > switchgroups_;
    uint32_t num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_topology_2eproto;
};
// -------------------------------------------------------------------

class Link final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ns3_proto.Link) */ {
 public:
  inline Link() : Link(nullptr) {}
  ~Link() override;
  explicit PROTOBUF_CONSTEXPR Link(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Link(const Link& from);
  Link(Link&& from) noexcept
    : Link() {
    *this = ::std::move(from);
  }

  inline Link& operator=(const Link& from) {
    CopyFrom(from);
    return *this;
  }
  inline Link& operator=(Link&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Link& default_instance() {
    return *internal_default_instance();
  }
  static inline const Link* internal_default_instance() {
    return reinterpret_cast<const Link*>(
               &_Link_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Link& a, Link& b) {
    a.Swap(&b);
  }
  inline void Swap(Link* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Link* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Link* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Link>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Link& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Link& from) {
    Link::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Link* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ns3_proto.Link";
  }
  protected:
  explicit Link(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRateFieldNumber = 5,
    kDelayFieldNumber = 6,
    kNode1FieldNumber = 1,
    kNode2FieldNumber = 2,
    kPort1FieldNumber = 3,
    kPort2FieldNumber = 4,
  };
  // string rate = 5;
  void clear_rate();
  const std::string& rate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rate();
  PROTOBUF_NODISCARD std::string* release_rate();
  void set_allocated_rate(std::string* rate);
  private:
  const std::string& _internal_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rate(const std::string& value);
  std::string* _internal_mutable_rate();
  public:

  // string delay = 6;
  void clear_delay();
  const std::string& delay() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_delay(ArgT0&& arg0, ArgT... args);
  std::string* mutable_delay();
  PROTOBUF_NODISCARD std::string* release_delay();
  void set_allocated_delay(std::string* delay);
  private:
  const std::string& _internal_delay() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_delay(const std::string& value);
  std::string* _internal_mutable_delay();
  public:

  // uint32 node1 = 1;
  void clear_node1();
  uint32_t node1() const;
  void set_node1(uint32_t value);
  private:
  uint32_t _internal_node1() const;
  void _internal_set_node1(uint32_t value);
  public:

  // uint32 node2 = 2;
  void clear_node2();
  uint32_t node2() const;
  void set_node2(uint32_t value);
  private:
  uint32_t _internal_node2() const;
  void _internal_set_node2(uint32_t value);
  public:

  // uint32 port1 = 3;
  void clear_port1();
  uint32_t port1() const;
  void set_port1(uint32_t value);
  private:
  uint32_t _internal_port1() const;
  void _internal_set_port1(uint32_t value);
  public:

  // uint32 port2 = 4;
  void clear_port2();
  uint32_t port2() const;
  void set_port2(uint32_t value);
  private:
  uint32_t _internal_port2() const;
  void _internal_set_port2(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ns3_proto.Link)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr delay_;
    uint32_t node1_;
    uint32_t node2_;
    uint32_t port1_;
    uint32_t port2_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_topology_2eproto;
};
// -------------------------------------------------------------------

class Topology final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ns3_proto.Topology) */ {
 public:
  inline Topology() : Topology(nullptr) {}
  ~Topology() override;
  explicit PROTOBUF_CONSTEXPR Topology(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Topology(const Topology& from);
  Topology(Topology&& from) noexcept
    : Topology() {
    *this = ::std::move(from);
  }

  inline Topology& operator=(const Topology& from) {
    CopyFrom(from);
    return *this;
  }
  inline Topology& operator=(Topology&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Topology& default_instance() {
    return *internal_default_instance();
  }
  static inline const Topology* internal_default_instance() {
    return reinterpret_cast<const Topology*>(
               &_Topology_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Topology& a, Topology& b) {
    a.Swap(&b);
  }
  inline void Swap(Topology* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Topology* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Topology* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Topology>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Topology& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Topology& from) {
    Topology::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Topology* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ns3_proto.Topology";
  }
  protected:
  explicit Topology(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinksFieldNumber = 3,
    kGlobalConfigFieldNumber = 1,
    kNodesFieldNumber = 2,
  };
  // repeated .ns3_proto.Link links = 3;
  int links_size() const;
  private:
  int _internal_links_size() const;
  public:
  void clear_links();
  ::ns3_proto::Link* mutable_links(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ns3_proto::Link >*
      mutable_links();
  private:
  const ::ns3_proto::Link& _internal_links(int index) const;
  ::ns3_proto::Link* _internal_add_links();
  public:
  const ::ns3_proto::Link& links(int index) const;
  ::ns3_proto::Link* add_links();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ns3_proto::Link >&
      links() const;

  // .ns3_proto.GlobalConfig globalConfig = 1;
  bool has_globalconfig() const;
  private:
  bool _internal_has_globalconfig() const;
  public:
  void clear_globalconfig();
  const ::ns3_proto::GlobalConfig& globalconfig() const;
  PROTOBUF_NODISCARD ::ns3_proto::GlobalConfig* release_globalconfig();
  ::ns3_proto::GlobalConfig* mutable_globalconfig();
  void set_allocated_globalconfig(::ns3_proto::GlobalConfig* globalconfig);
  private:
  const ::ns3_proto::GlobalConfig& _internal_globalconfig() const;
  ::ns3_proto::GlobalConfig* _internal_mutable_globalconfig();
  public:
  void unsafe_arena_set_allocated_globalconfig(
      ::ns3_proto::GlobalConfig* globalconfig);
  ::ns3_proto::GlobalConfig* unsafe_arena_release_globalconfig();

  // .ns3_proto.AllNodes nodes = 2;
  bool has_nodes() const;
  private:
  bool _internal_has_nodes() const;
  public:
  void clear_nodes();
  const ::ns3_proto::AllNodes& nodes() const;
  PROTOBUF_NODISCARD ::ns3_proto::AllNodes* release_nodes();
  ::ns3_proto::AllNodes* mutable_nodes();
  void set_allocated_nodes(::ns3_proto::AllNodes* nodes);
  private:
  const ::ns3_proto::AllNodes& _internal_nodes() const;
  ::ns3_proto::AllNodes* _internal_mutable_nodes();
  public:
  void unsafe_arena_set_allocated_nodes(
      ::ns3_proto::AllNodes* nodes);
  ::ns3_proto::AllNodes* unsafe_arena_release_nodes();

  // @@protoc_insertion_point(class_scope:ns3_proto.Topology)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ns3_proto::Link > links_;
    ::ns3_proto::GlobalConfig* globalconfig_;
    ::ns3_proto::AllNodes* nodes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_topology_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GlobalConfig

// optional uint32 randomSeed = 1;
inline bool GlobalConfig::_internal_has_randomseed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GlobalConfig::has_randomseed() const {
  return _internal_has_randomseed();
}
inline void GlobalConfig::clear_randomseed() {
  _impl_.randomseed_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t GlobalConfig::_internal_randomseed() const {
  return _impl_.randomseed_;
}
inline uint32_t GlobalConfig::randomseed() const {
  // @@protoc_insertion_point(field_get:ns3_proto.GlobalConfig.randomSeed)
  return _internal_randomseed();
}
inline void GlobalConfig::_internal_set_randomseed(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.randomseed_ = value;
}
inline void GlobalConfig::set_randomseed(uint32_t value) {
  _internal_set_randomseed(value);
  // @@protoc_insertion_point(field_set:ns3_proto.GlobalConfig.randomSeed)
}

// -------------------------------------------------------------------

// HostPortConfig

// bool pfcEnabled = 1;
inline void HostPortConfig::clear_pfcenabled() {
  _impl_.pfcenabled_ = false;
}
inline bool HostPortConfig::_internal_pfcenabled() const {
  return _impl_.pfcenabled_;
}
inline bool HostPortConfig::pfcenabled() const {
  // @@protoc_insertion_point(field_get:ns3_proto.HostPortConfig.pfcEnabled)
  return _internal_pfcenabled();
}
inline void HostPortConfig::_internal_set_pfcenabled(bool value) {
  
  _impl_.pfcenabled_ = value;
}
inline void HostPortConfig::set_pfcenabled(bool value) {
  _internal_set_pfcenabled(value);
  // @@protoc_insertion_point(field_set:ns3_proto.HostPortConfig.pfcEnabled)
}

// -------------------------------------------------------------------

// HostGroup

// uint32 nodesNum = 1;
inline void HostGroup::clear_nodesnum() {
  _impl_.nodesnum_ = 0u;
}
inline uint32_t HostGroup::_internal_nodesnum() const {
  return _impl_.nodesnum_;
}
inline uint32_t HostGroup::nodesnum() const {
  // @@protoc_insertion_point(field_get:ns3_proto.HostGroup.nodesNum)
  return _internal_nodesnum();
}
inline void HostGroup::_internal_set_nodesnum(uint32_t value) {
  
  _impl_.nodesnum_ = value;
}
inline void HostGroup::set_nodesnum(uint32_t value) {
  _internal_set_nodesnum(value);
  // @@protoc_insertion_point(field_set:ns3_proto.HostGroup.nodesNum)
}

// uint32 baseIndex = 2;
inline void HostGroup::clear_baseindex() {
  _impl_.baseindex_ = 0u;
}
inline uint32_t HostGroup::_internal_baseindex() const {
  return _impl_.baseindex_;
}
inline uint32_t HostGroup::baseindex() const {
  // @@protoc_insertion_point(field_get:ns3_proto.HostGroup.baseIndex)
  return _internal_baseindex();
}
inline void HostGroup::_internal_set_baseindex(uint32_t value) {
  
  _impl_.baseindex_ = value;
}
inline void HostGroup::set_baseindex(uint32_t value) {
  _internal_set_baseindex(value);
  // @@protoc_insertion_point(field_set:ns3_proto.HostGroup.baseIndex)
}

// repeated .ns3_proto.HostPortConfig ports = 3;
inline int HostGroup::_internal_ports_size() const {
  return _impl_.ports_.size();
}
inline int HostGroup::ports_size() const {
  return _internal_ports_size();
}
inline void HostGroup::clear_ports() {
  _impl_.ports_.Clear();
}
inline ::ns3_proto::HostPortConfig* HostGroup::mutable_ports(int index) {
  // @@protoc_insertion_point(field_mutable:ns3_proto.HostGroup.ports)
  return _impl_.ports_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ns3_proto::HostPortConfig >*
HostGroup::mutable_ports() {
  // @@protoc_insertion_point(field_mutable_list:ns3_proto.HostGroup.ports)
  return &_impl_.ports_;
}
inline const ::ns3_proto::HostPortConfig& HostGroup::_internal_ports(int index) const {
  return _impl_.ports_.Get(index);
}
inline const ::ns3_proto::HostPortConfig& HostGroup::ports(int index) const {
  // @@protoc_insertion_point(field_get:ns3_proto.HostGroup.ports)
  return _internal_ports(index);
}
inline ::ns3_proto::HostPortConfig* HostGroup::_internal_add_ports() {
  return _impl_.ports_.Add();
}
inline ::ns3_proto::HostPortConfig* HostGroup::add_ports() {
  ::ns3_proto::HostPortConfig* _add = _internal_add_ports();
  // @@protoc_insertion_point(field_add:ns3_proto.HostGroup.ports)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ns3_proto::HostPortConfig >&
HostGroup::ports() const {
  // @@protoc_insertion_point(field_list:ns3_proto.HostGroup.ports)
  return _impl_.ports_;
}

// -------------------------------------------------------------------

// PortQueueConfig

// optional string pfcReserved = 1;
inline bool PortQueueConfig::_internal_has_pfcreserved() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PortQueueConfig::has_pfcreserved() const {
  return _internal_has_pfcreserved();
}
inline void PortQueueConfig::clear_pfcreserved() {
  _impl_.pfcreserved_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PortQueueConfig::pfcreserved() const {
  // @@protoc_insertion_point(field_get:ns3_proto.PortQueueConfig.pfcReserved)
  return _internal_pfcreserved();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PortQueueConfig::set_pfcreserved(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.pfcreserved_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ns3_proto.PortQueueConfig.pfcReserved)
}
inline std::string* PortQueueConfig::mutable_pfcreserved() {
  std::string* _s = _internal_mutable_pfcreserved();
  // @@protoc_insertion_point(field_mutable:ns3_proto.PortQueueConfig.pfcReserved)
  return _s;
}
inline const std::string& PortQueueConfig::_internal_pfcreserved() const {
  return _impl_.pfcreserved_.Get();
}
inline void PortQueueConfig::_internal_set_pfcreserved(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.pfcreserved_.Set(value, GetArenaForAllocation());
}
inline std::string* PortQueueConfig::_internal_mutable_pfcreserved() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.pfcreserved_.Mutable(GetArenaForAllocation());
}
inline std::string* PortQueueConfig::release_pfcreserved() {
  // @@protoc_insertion_point(field_release:ns3_proto.PortQueueConfig.pfcReserved)
  if (!_internal_has_pfcreserved()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.pfcreserved_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pfcreserved_.IsDefault()) {
    _impl_.pfcreserved_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PortQueueConfig::set_allocated_pfcreserved(std::string* pfcreserved) {
  if (pfcreserved != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.pfcreserved_.SetAllocated(pfcreserved, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pfcreserved_.IsDefault()) {
    _impl_.pfcreserved_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ns3_proto.PortQueueConfig.pfcReserved)
}

// optional string pfcHeadroom = 2;
inline bool PortQueueConfig::_internal_has_pfcheadroom() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PortQueueConfig::has_pfcheadroom() const {
  return _internal_has_pfcheadroom();
}
inline void PortQueueConfig::clear_pfcheadroom() {
  _impl_.pfcheadroom_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PortQueueConfig::pfcheadroom() const {
  // @@protoc_insertion_point(field_get:ns3_proto.PortQueueConfig.pfcHeadroom)
  return _internal_pfcheadroom();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PortQueueConfig::set_pfcheadroom(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.pfcheadroom_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ns3_proto.PortQueueConfig.pfcHeadroom)
}
inline std::string* PortQueueConfig::mutable_pfcheadroom() {
  std::string* _s = _internal_mutable_pfcheadroom();
  // @@protoc_insertion_point(field_mutable:ns3_proto.PortQueueConfig.pfcHeadroom)
  return _s;
}
inline const std::string& PortQueueConfig::_internal_pfcheadroom() const {
  return _impl_.pfcheadroom_.Get();
}
inline void PortQueueConfig::_internal_set_pfcheadroom(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pfcheadroom_.Set(value, GetArenaForAllocation());
}
inline std::string* PortQueueConfig::_internal_mutable_pfcheadroom() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.pfcheadroom_.Mutable(GetArenaForAllocation());
}
inline std::string* PortQueueConfig::release_pfcheadroom() {
  // @@protoc_insertion_point(field_release:ns3_proto.PortQueueConfig.pfcHeadroom)
  if (!_internal_has_pfcheadroom()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.pfcheadroom_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pfcheadroom_.IsDefault()) {
    _impl_.pfcheadroom_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PortQueueConfig::set_allocated_pfcheadroom(std::string* pfcheadroom) {
  if (pfcheadroom != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.pfcheadroom_.SetAllocated(pfcheadroom, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pfcheadroom_.IsDefault()) {
    _impl_.pfcheadroom_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ns3_proto.PortQueueConfig.pfcHeadroom)
}

// optional string ecnKMin = 4;
inline bool PortQueueConfig::_internal_has_ecnkmin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PortQueueConfig::has_ecnkmin() const {
  return _internal_has_ecnkmin();
}
inline void PortQueueConfig::clear_ecnkmin() {
  _impl_.ecnkmin_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PortQueueConfig::ecnkmin() const {
  // @@protoc_insertion_point(field_get:ns3_proto.PortQueueConfig.ecnKMin)
  return _internal_ecnkmin();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PortQueueConfig::set_ecnkmin(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.ecnkmin_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ns3_proto.PortQueueConfig.ecnKMin)
}
inline std::string* PortQueueConfig::mutable_ecnkmin() {
  std::string* _s = _internal_mutable_ecnkmin();
  // @@protoc_insertion_point(field_mutable:ns3_proto.PortQueueConfig.ecnKMin)
  return _s;
}
inline const std::string& PortQueueConfig::_internal_ecnkmin() const {
  return _impl_.ecnkmin_.Get();
}
inline void PortQueueConfig::_internal_set_ecnkmin(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ecnkmin_.Set(value, GetArenaForAllocation());
}
inline std::string* PortQueueConfig::_internal_mutable_ecnkmin() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.ecnkmin_.Mutable(GetArenaForAllocation());
}
inline std::string* PortQueueConfig::release_ecnkmin() {
  // @@protoc_insertion_point(field_release:ns3_proto.PortQueueConfig.ecnKMin)
  if (!_internal_has_ecnkmin()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.ecnkmin_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ecnkmin_.IsDefault()) {
    _impl_.ecnkmin_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PortQueueConfig::set_allocated_ecnkmin(std::string* ecnkmin) {
  if (ecnkmin != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.ecnkmin_.SetAllocated(ecnkmin, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ecnkmin_.IsDefault()) {
    _impl_.ecnkmin_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ns3_proto.PortQueueConfig.ecnKMin)
}

// optional string ecnKMax = 5;
inline bool PortQueueConfig::_internal_has_ecnkmax() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PortQueueConfig::has_ecnkmax() const {
  return _internal_has_ecnkmax();
}
inline void PortQueueConfig::clear_ecnkmax() {
  _impl_.ecnkmax_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& PortQueueConfig::ecnkmax() const {
  // @@protoc_insertion_point(field_get:ns3_proto.PortQueueConfig.ecnKMax)
  return _internal_ecnkmax();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PortQueueConfig::set_ecnkmax(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.ecnkmax_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ns3_proto.PortQueueConfig.ecnKMax)
}
inline std::string* PortQueueConfig::mutable_ecnkmax() {
  std::string* _s = _internal_mutable_ecnkmax();
  // @@protoc_insertion_point(field_mutable:ns3_proto.PortQueueConfig.ecnKMax)
  return _s;
}
inline const std::string& PortQueueConfig::_internal_ecnkmax() const {
  return _impl_.ecnkmax_.Get();
}
inline void PortQueueConfig::_internal_set_ecnkmax(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.ecnkmax_.Set(value, GetArenaForAllocation());
}
inline std::string* PortQueueConfig::_internal_mutable_ecnkmax() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.ecnkmax_.Mutable(GetArenaForAllocation());
}
inline std::string* PortQueueConfig::release_ecnkmax() {
  // @@protoc_insertion_point(field_release:ns3_proto.PortQueueConfig.ecnKMax)
  if (!_internal_has_ecnkmax()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.ecnkmax_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ecnkmax_.IsDefault()) {
    _impl_.ecnkmax_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PortQueueConfig::set_allocated_ecnkmax(std::string* ecnkmax) {
  if (ecnkmax != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.ecnkmax_.SetAllocated(ecnkmax, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ecnkmax_.IsDefault()) {
    _impl_.ecnkmax_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ns3_proto.PortQueueConfig.ecnKMax)
}

// optional double ecnPMax = 6;
inline bool PortQueueConfig::_internal_has_ecnpmax() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PortQueueConfig::has_ecnpmax() const {
  return _internal_has_ecnpmax();
}
inline void PortQueueConfig::clear_ecnpmax() {
  _impl_.ecnpmax_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double PortQueueConfig::_internal_ecnpmax() const {
  return _impl_.ecnpmax_;
}
inline double PortQueueConfig::ecnpmax() const {
  // @@protoc_insertion_point(field_get:ns3_proto.PortQueueConfig.ecnPMax)
  return _internal_ecnpmax();
}
inline void PortQueueConfig::_internal_set_ecnpmax(double value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.ecnpmax_ = value;
}
inline void PortQueueConfig::set_ecnpmax(double value) {
  _internal_set_ecnpmax(value);
  // @@protoc_insertion_point(field_set:ns3_proto.PortQueueConfig.ecnPMax)
}

// -------------------------------------------------------------------

// SwitchPortConfig

// bool pfcEnabled = 1;
inline void SwitchPortConfig::clear_pfcenabled() {
  _impl_.pfcenabled_ = false;
}
inline bool SwitchPortConfig::_internal_pfcenabled() const {
  return _impl_.pfcenabled_;
}
inline bool SwitchPortConfig::pfcenabled() const {
  // @@protoc_insertion_point(field_get:ns3_proto.SwitchPortConfig.pfcEnabled)
  return _internal_pfcenabled();
}
inline void SwitchPortConfig::_internal_set_pfcenabled(bool value) {
  
  _impl_.pfcenabled_ = value;
}
inline void SwitchPortConfig::set_pfcenabled(bool value) {
  _internal_set_pfcenabled(value);
  // @@protoc_insertion_point(field_set:ns3_proto.SwitchPortConfig.pfcEnabled)
}

// optional bool pfcPassThrough = 2;
inline bool SwitchPortConfig::_internal_has_pfcpassthrough() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SwitchPortConfig::has_pfcpassthrough() const {
  return _internal_has_pfcpassthrough();
}
inline void SwitchPortConfig::clear_pfcpassthrough() {
  _impl_.pfcpassthrough_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool SwitchPortConfig::_internal_pfcpassthrough() const {
  return _impl_.pfcpassthrough_;
}
inline bool SwitchPortConfig::pfcpassthrough() const {
  // @@protoc_insertion_point(field_get:ns3_proto.SwitchPortConfig.pfcPassThrough)
  return _internal_pfcpassthrough();
}
inline void SwitchPortConfig::_internal_set_pfcpassthrough(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.pfcpassthrough_ = value;
}
inline void SwitchPortConfig::set_pfcpassthrough(bool value) {
  _internal_set_pfcpassthrough(value);
  // @@protoc_insertion_point(field_set:ns3_proto.SwitchPortConfig.pfcPassThrough)
}

// bool ecnEnabled = 3;
inline void SwitchPortConfig::clear_ecnenabled() {
  _impl_.ecnenabled_ = false;
}
inline bool SwitchPortConfig::_internal_ecnenabled() const {
  return _impl_.ecnenabled_;
}
inline bool SwitchPortConfig::ecnenabled() const {
  // @@protoc_insertion_point(field_get:ns3_proto.SwitchPortConfig.ecnEnabled)
  return _internal_ecnenabled();
}
inline void SwitchPortConfig::_internal_set_ecnenabled(bool value) {
  
  _impl_.ecnenabled_ = value;
}
inline void SwitchPortConfig::set_ecnenabled(bool value) {
  _internal_set_ecnenabled(value);
  // @@protoc_insertion_point(field_set:ns3_proto.SwitchPortConfig.ecnEnabled)
}

// repeated .ns3_proto.PortQueueConfig queues = 4;
inline int SwitchPortConfig::_internal_queues_size() const {
  return _impl_.queues_.size();
}
inline int SwitchPortConfig::queues_size() const {
  return _internal_queues_size();
}
inline void SwitchPortConfig::clear_queues() {
  _impl_.queues_.Clear();
}
inline ::ns3_proto::PortQueueConfig* SwitchPortConfig::mutable_queues(int index) {
  // @@protoc_insertion_point(field_mutable:ns3_proto.SwitchPortConfig.queues)
  return _impl_.queues_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ns3_proto::PortQueueConfig >*
SwitchPortConfig::mutable_queues() {
  // @@protoc_insertion_point(field_mutable_list:ns3_proto.SwitchPortConfig.queues)
  return &_impl_.queues_;
}
inline const ::ns3_proto::PortQueueConfig& SwitchPortConfig::_internal_queues(int index) const {
  return _impl_.queues_.Get(index);
}
inline const ::ns3_proto::PortQueueConfig& SwitchPortConfig::queues(int index) const {
  // @@protoc_insertion_point(field_get:ns3_proto.SwitchPortConfig.queues)
  return _internal_queues(index);
}
inline ::ns3_proto::PortQueueConfig* SwitchPortConfig::_internal_add_queues() {
  return _impl_.queues_.Add();
}
inline ::ns3_proto::PortQueueConfig* SwitchPortConfig::add_queues() {
  ::ns3_proto::PortQueueConfig* _add = _internal_add_queues();
  // @@protoc_insertion_point(field_add:ns3_proto.SwitchPortConfig.queues)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ns3_proto::PortQueueConfig >&
SwitchPortConfig::queues() const {
  // @@protoc_insertion_point(field_list:ns3_proto.SwitchPortConfig.queues)
  return _impl_.queues_;
}

// -------------------------------------------------------------------

// SwitchMmuConfig

// string bufferSize = 1;
inline void SwitchMmuConfig::clear_buffersize() {
  _impl_.buffersize_.ClearToEmpty();
}
inline const std::string& SwitchMmuConfig::buffersize() const {
  // @@protoc_insertion_point(field_get:ns3_proto.SwitchMmuConfig.bufferSize)
  return _internal_buffersize();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SwitchMmuConfig::set_buffersize(ArgT0&& arg0, ArgT... args) {
 
 _impl_.buffersize_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ns3_proto.SwitchMmuConfig.bufferSize)
}
inline std::string* SwitchMmuConfig::mutable_buffersize() {
  std::string* _s = _internal_mutable_buffersize();
  // @@protoc_insertion_point(field_mutable:ns3_proto.SwitchMmuConfig.bufferSize)
  return _s;
}
inline const std::string& SwitchMmuConfig::_internal_buffersize() const {
  return _impl_.buffersize_.Get();
}
inline void SwitchMmuConfig::_internal_set_buffersize(const std::string& value) {
  
  _impl_.buffersize_.Set(value, GetArenaForAllocation());
}
inline std::string* SwitchMmuConfig::_internal_mutable_buffersize() {
  
  return _impl_.buffersize_.Mutable(GetArenaForAllocation());
}
inline std::string* SwitchMmuConfig::release_buffersize() {
  // @@protoc_insertion_point(field_release:ns3_proto.SwitchMmuConfig.bufferSize)
  return _impl_.buffersize_.Release();
}
inline void SwitchMmuConfig::set_allocated_buffersize(std::string* buffersize) {
  if (buffersize != nullptr) {
    
  } else {
    
  }
  _impl_.buffersize_.SetAllocated(buffersize, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.buffersize_.IsDefault()) {
    _impl_.buffersize_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ns3_proto.SwitchMmuConfig.bufferSize)
}

// optional uint32 pfcDynamicShift = 2;
inline bool SwitchMmuConfig::_internal_has_pfcdynamicshift() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SwitchMmuConfig::has_pfcdynamicshift() const {
  return _internal_has_pfcdynamicshift();
}
inline void SwitchMmuConfig::clear_pfcdynamicshift() {
  _impl_.pfcdynamicshift_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t SwitchMmuConfig::_internal_pfcdynamicshift() const {
  return _impl_.pfcdynamicshift_;
}
inline uint32_t SwitchMmuConfig::pfcdynamicshift() const {
  // @@protoc_insertion_point(field_get:ns3_proto.SwitchMmuConfig.pfcDynamicShift)
  return _internal_pfcdynamicshift();
}
inline void SwitchMmuConfig::_internal_set_pfcdynamicshift(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.pfcdynamicshift_ = value;
}
inline void SwitchMmuConfig::set_pfcdynamicshift(uint32_t value) {
  _internal_set_pfcdynamicshift(value);
  // @@protoc_insertion_point(field_set:ns3_proto.SwitchMmuConfig.pfcDynamicShift)
}

// -------------------------------------------------------------------

// SwitchGroup

// uint32 nodesNum = 1;
inline void SwitchGroup::clear_nodesnum() {
  _impl_.nodesnum_ = 0u;
}
inline uint32_t SwitchGroup::_internal_nodesnum() const {
  return _impl_.nodesnum_;
}
inline uint32_t SwitchGroup::nodesnum() const {
  // @@protoc_insertion_point(field_get:ns3_proto.SwitchGroup.nodesNum)
  return _internal_nodesnum();
}
inline void SwitchGroup::_internal_set_nodesnum(uint32_t value) {
  
  _impl_.nodesnum_ = value;
}
inline void SwitchGroup::set_nodesnum(uint32_t value) {
  _internal_set_nodesnum(value);
  // @@protoc_insertion_point(field_set:ns3_proto.SwitchGroup.nodesNum)
}

// uint32 baseIndex = 2;
inline void SwitchGroup::clear_baseindex() {
  _impl_.baseindex_ = 0u;
}
inline uint32_t SwitchGroup::_internal_baseindex() const {
  return _impl_.baseindex_;
}
inline uint32_t SwitchGroup::baseindex() const {
  // @@protoc_insertion_point(field_get:ns3_proto.SwitchGroup.baseIndex)
  return _internal_baseindex();
}
inline void SwitchGroup::_internal_set_baseindex(uint32_t value) {
  
  _impl_.baseindex_ = value;
}
inline void SwitchGroup::set_baseindex(uint32_t value) {
  _internal_set_baseindex(value);
  // @@protoc_insertion_point(field_set:ns3_proto.SwitchGroup.baseIndex)
}

// .ns3_proto.SwitchMmuConfig mmu = 3;
inline bool SwitchGroup::_internal_has_mmu() const {
  return this != internal_default_instance() && _impl_.mmu_ != nullptr;
}
inline bool SwitchGroup::has_mmu() const {
  return _internal_has_mmu();
}
inline void SwitchGroup::clear_mmu() {
  if (GetArenaForAllocation() == nullptr && _impl_.mmu_ != nullptr) {
    delete _impl_.mmu_;
  }
  _impl_.mmu_ = nullptr;
}
inline const ::ns3_proto::SwitchMmuConfig& SwitchGroup::_internal_mmu() const {
  const ::ns3_proto::SwitchMmuConfig* p = _impl_.mmu_;
  return p != nullptr ? *p : reinterpret_cast<const ::ns3_proto::SwitchMmuConfig&>(
      ::ns3_proto::_SwitchMmuConfig_default_instance_);
}
inline const ::ns3_proto::SwitchMmuConfig& SwitchGroup::mmu() const {
  // @@protoc_insertion_point(field_get:ns3_proto.SwitchGroup.mmu)
  return _internal_mmu();
}
inline void SwitchGroup::unsafe_arena_set_allocated_mmu(
    ::ns3_proto::SwitchMmuConfig* mmu) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mmu_);
  }
  _impl_.mmu_ = mmu;
  if (mmu) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ns3_proto.SwitchGroup.mmu)
}
inline ::ns3_proto::SwitchMmuConfig* SwitchGroup::release_mmu() {
  
  ::ns3_proto::SwitchMmuConfig* temp = _impl_.mmu_;
  _impl_.mmu_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ns3_proto::SwitchMmuConfig* SwitchGroup::unsafe_arena_release_mmu() {
  // @@protoc_insertion_point(field_release:ns3_proto.SwitchGroup.mmu)
  
  ::ns3_proto::SwitchMmuConfig* temp = _impl_.mmu_;
  _impl_.mmu_ = nullptr;
  return temp;
}
inline ::ns3_proto::SwitchMmuConfig* SwitchGroup::_internal_mutable_mmu() {
  
  if (_impl_.mmu_ == nullptr) {
    auto* p = CreateMaybeMessage<::ns3_proto::SwitchMmuConfig>(GetArenaForAllocation());
    _impl_.mmu_ = p;
  }
  return _impl_.mmu_;
}
inline ::ns3_proto::SwitchMmuConfig* SwitchGroup::mutable_mmu() {
  ::ns3_proto::SwitchMmuConfig* _msg = _internal_mutable_mmu();
  // @@protoc_insertion_point(field_mutable:ns3_proto.SwitchGroup.mmu)
  return _msg;
}
inline void SwitchGroup::set_allocated_mmu(::ns3_proto::SwitchMmuConfig* mmu) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.mmu_;
  }
  if (mmu) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mmu);
    if (message_arena != submessage_arena) {
      mmu = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mmu, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.mmu_ = mmu;
  // @@protoc_insertion_point(field_set_allocated:ns3_proto.SwitchGroup.mmu)
}

// uint32 queueNum = 4;
inline void SwitchGroup::clear_queuenum() {
  _impl_.queuenum_ = 0u;
}
inline uint32_t SwitchGroup::_internal_queuenum() const {
  return _impl_.queuenum_;
}
inline uint32_t SwitchGroup::queuenum() const {
  // @@protoc_insertion_point(field_get:ns3_proto.SwitchGroup.queueNum)
  return _internal_queuenum();
}
inline void SwitchGroup::_internal_set_queuenum(uint32_t value) {
  
  _impl_.queuenum_ = value;
}
inline void SwitchGroup::set_queuenum(uint32_t value) {
  _internal_set_queuenum(value);
  // @@protoc_insertion_point(field_set:ns3_proto.SwitchGroup.queueNum)
}

// repeated .ns3_proto.SwitchPortConfig ports = 5;
inline int SwitchGroup::_internal_ports_size() const {
  return _impl_.ports_.size();
}
inline int SwitchGroup::ports_size() const {
  return _internal_ports_size();
}
inline void SwitchGroup::clear_ports() {
  _impl_.ports_.Clear();
}
inline ::ns3_proto::SwitchPortConfig* SwitchGroup::mutable_ports(int index) {
  // @@protoc_insertion_point(field_mutable:ns3_proto.SwitchGroup.ports)
  return _impl_.ports_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ns3_proto::SwitchPortConfig >*
SwitchGroup::mutable_ports() {
  // @@protoc_insertion_point(field_mutable_list:ns3_proto.SwitchGroup.ports)
  return &_impl_.ports_;
}
inline const ::ns3_proto::SwitchPortConfig& SwitchGroup::_internal_ports(int index) const {
  return _impl_.ports_.Get(index);
}
inline const ::ns3_proto::SwitchPortConfig& SwitchGroup::ports(int index) const {
  // @@protoc_insertion_point(field_get:ns3_proto.SwitchGroup.ports)
  return _internal_ports(index);
}
inline ::ns3_proto::SwitchPortConfig* SwitchGroup::_internal_add_ports() {
  return _impl_.ports_.Add();
}
inline ::ns3_proto::SwitchPortConfig* SwitchGroup::add_ports() {
  ::ns3_proto::SwitchPortConfig* _add = _internal_add_ports();
  // @@protoc_insertion_point(field_add:ns3_proto.SwitchGroup.ports)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ns3_proto::SwitchPortConfig >&
SwitchGroup::ports() const {
  // @@protoc_insertion_point(field_list:ns3_proto.SwitchGroup.ports)
  return _impl_.ports_;
}

// -------------------------------------------------------------------

// AllNodes

// uint32 num = 1;
inline void AllNodes::clear_num() {
  _impl_.num_ = 0u;
}
inline uint32_t AllNodes::_internal_num() const {
  return _impl_.num_;
}
inline uint32_t AllNodes::num() const {
  // @@protoc_insertion_point(field_get:ns3_proto.AllNodes.num)
  return _internal_num();
}
inline void AllNodes::_internal_set_num(uint32_t value) {
  
  _impl_.num_ = value;
}
inline void AllNodes::set_num(uint32_t value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:ns3_proto.AllNodes.num)
}

// repeated .ns3_proto.HostGroup hostGroups = 2;
inline int AllNodes::_internal_hostgroups_size() const {
  return _impl_.hostgroups_.size();
}
inline int AllNodes::hostgroups_size() const {
  return _internal_hostgroups_size();
}
inline void AllNodes::clear_hostgroups() {
  _impl_.hostgroups_.Clear();
}
inline ::ns3_proto::HostGroup* AllNodes::mutable_hostgroups(int index) {
  // @@protoc_insertion_point(field_mutable:ns3_proto.AllNodes.hostGroups)
  return _impl_.hostgroups_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ns3_proto::HostGroup >*
AllNodes::mutable_hostgroups() {
  // @@protoc_insertion_point(field_mutable_list:ns3_proto.AllNodes.hostGroups)
  return &_impl_.hostgroups_;
}
inline const ::ns3_proto::HostGroup& AllNodes::_internal_hostgroups(int index) const {
  return _impl_.hostgroups_.Get(index);
}
inline const ::ns3_proto::HostGroup& AllNodes::hostgroups(int index) const {
  // @@protoc_insertion_point(field_get:ns3_proto.AllNodes.hostGroups)
  return _internal_hostgroups(index);
}
inline ::ns3_proto::HostGroup* AllNodes::_internal_add_hostgroups() {
  return _impl_.hostgroups_.Add();
}
inline ::ns3_proto::HostGroup* AllNodes::add_hostgroups() {
  ::ns3_proto::HostGroup* _add = _internal_add_hostgroups();
  // @@protoc_insertion_point(field_add:ns3_proto.AllNodes.hostGroups)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ns3_proto::HostGroup >&
AllNodes::hostgroups() const {
  // @@protoc_insertion_point(field_list:ns3_proto.AllNodes.hostGroups)
  return _impl_.hostgroups_;
}

// repeated .ns3_proto.SwitchGroup switchGroups = 3;
inline int AllNodes::_internal_switchgroups_size() const {
  return _impl_.switchgroups_.size();
}
inline int AllNodes::switchgroups_size() const {
  return _internal_switchgroups_size();
}
inline void AllNodes::clear_switchgroups() {
  _impl_.switchgroups_.Clear();
}
inline ::ns3_proto::SwitchGroup* AllNodes::mutable_switchgroups(int index) {
  // @@protoc_insertion_point(field_mutable:ns3_proto.AllNodes.switchGroups)
  return _impl_.switchgroups_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ns3_proto::SwitchGroup >*
AllNodes::mutable_switchgroups() {
  // @@protoc_insertion_point(field_mutable_list:ns3_proto.AllNodes.switchGroups)
  return &_impl_.switchgroups_;
}
inline const ::ns3_proto::SwitchGroup& AllNodes::_internal_switchgroups(int index) const {
  return _impl_.switchgroups_.Get(index);
}
inline const ::ns3_proto::SwitchGroup& AllNodes::switchgroups(int index) const {
  // @@protoc_insertion_point(field_get:ns3_proto.AllNodes.switchGroups)
  return _internal_switchgroups(index);
}
inline ::ns3_proto::SwitchGroup* AllNodes::_internal_add_switchgroups() {
  return _impl_.switchgroups_.Add();
}
inline ::ns3_proto::SwitchGroup* AllNodes::add_switchgroups() {
  ::ns3_proto::SwitchGroup* _add = _internal_add_switchgroups();
  // @@protoc_insertion_point(field_add:ns3_proto.AllNodes.switchGroups)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ns3_proto::SwitchGroup >&
AllNodes::switchgroups() const {
  // @@protoc_insertion_point(field_list:ns3_proto.AllNodes.switchGroups)
  return _impl_.switchgroups_;
}

// -------------------------------------------------------------------

// Link

// uint32 node1 = 1;
inline void Link::clear_node1() {
  _impl_.node1_ = 0u;
}
inline uint32_t Link::_internal_node1() const {
  return _impl_.node1_;
}
inline uint32_t Link::node1() const {
  // @@protoc_insertion_point(field_get:ns3_proto.Link.node1)
  return _internal_node1();
}
inline void Link::_internal_set_node1(uint32_t value) {
  
  _impl_.node1_ = value;
}
inline void Link::set_node1(uint32_t value) {
  _internal_set_node1(value);
  // @@protoc_insertion_point(field_set:ns3_proto.Link.node1)
}

// uint32 node2 = 2;
inline void Link::clear_node2() {
  _impl_.node2_ = 0u;
}
inline uint32_t Link::_internal_node2() const {
  return _impl_.node2_;
}
inline uint32_t Link::node2() const {
  // @@protoc_insertion_point(field_get:ns3_proto.Link.node2)
  return _internal_node2();
}
inline void Link::_internal_set_node2(uint32_t value) {
  
  _impl_.node2_ = value;
}
inline void Link::set_node2(uint32_t value) {
  _internal_set_node2(value);
  // @@protoc_insertion_point(field_set:ns3_proto.Link.node2)
}

// uint32 port1 = 3;
inline void Link::clear_port1() {
  _impl_.port1_ = 0u;
}
inline uint32_t Link::_internal_port1() const {
  return _impl_.port1_;
}
inline uint32_t Link::port1() const {
  // @@protoc_insertion_point(field_get:ns3_proto.Link.port1)
  return _internal_port1();
}
inline void Link::_internal_set_port1(uint32_t value) {
  
  _impl_.port1_ = value;
}
inline void Link::set_port1(uint32_t value) {
  _internal_set_port1(value);
  // @@protoc_insertion_point(field_set:ns3_proto.Link.port1)
}

// uint32 port2 = 4;
inline void Link::clear_port2() {
  _impl_.port2_ = 0u;
}
inline uint32_t Link::_internal_port2() const {
  return _impl_.port2_;
}
inline uint32_t Link::port2() const {
  // @@protoc_insertion_point(field_get:ns3_proto.Link.port2)
  return _internal_port2();
}
inline void Link::_internal_set_port2(uint32_t value) {
  
  _impl_.port2_ = value;
}
inline void Link::set_port2(uint32_t value) {
  _internal_set_port2(value);
  // @@protoc_insertion_point(field_set:ns3_proto.Link.port2)
}

// string rate = 5;
inline void Link::clear_rate() {
  _impl_.rate_.ClearToEmpty();
}
inline const std::string& Link::rate() const {
  // @@protoc_insertion_point(field_get:ns3_proto.Link.rate)
  return _internal_rate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Link::set_rate(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rate_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ns3_proto.Link.rate)
}
inline std::string* Link::mutable_rate() {
  std::string* _s = _internal_mutable_rate();
  // @@protoc_insertion_point(field_mutable:ns3_proto.Link.rate)
  return _s;
}
inline const std::string& Link::_internal_rate() const {
  return _impl_.rate_.Get();
}
inline void Link::_internal_set_rate(const std::string& value) {
  
  _impl_.rate_.Set(value, GetArenaForAllocation());
}
inline std::string* Link::_internal_mutable_rate() {
  
  return _impl_.rate_.Mutable(GetArenaForAllocation());
}
inline std::string* Link::release_rate() {
  // @@protoc_insertion_point(field_release:ns3_proto.Link.rate)
  return _impl_.rate_.Release();
}
inline void Link::set_allocated_rate(std::string* rate) {
  if (rate != nullptr) {
    
  } else {
    
  }
  _impl_.rate_.SetAllocated(rate, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rate_.IsDefault()) {
    _impl_.rate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ns3_proto.Link.rate)
}

// string delay = 6;
inline void Link::clear_delay() {
  _impl_.delay_.ClearToEmpty();
}
inline const std::string& Link::delay() const {
  // @@protoc_insertion_point(field_get:ns3_proto.Link.delay)
  return _internal_delay();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Link::set_delay(ArgT0&& arg0, ArgT... args) {
 
 _impl_.delay_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ns3_proto.Link.delay)
}
inline std::string* Link::mutable_delay() {
  std::string* _s = _internal_mutable_delay();
  // @@protoc_insertion_point(field_mutable:ns3_proto.Link.delay)
  return _s;
}
inline const std::string& Link::_internal_delay() const {
  return _impl_.delay_.Get();
}
inline void Link::_internal_set_delay(const std::string& value) {
  
  _impl_.delay_.Set(value, GetArenaForAllocation());
}
inline std::string* Link::_internal_mutable_delay() {
  
  return _impl_.delay_.Mutable(GetArenaForAllocation());
}
inline std::string* Link::release_delay() {
  // @@protoc_insertion_point(field_release:ns3_proto.Link.delay)
  return _impl_.delay_.Release();
}
inline void Link::set_allocated_delay(std::string* delay) {
  if (delay != nullptr) {
    
  } else {
    
  }
  _impl_.delay_.SetAllocated(delay, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.delay_.IsDefault()) {
    _impl_.delay_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ns3_proto.Link.delay)
}

// -------------------------------------------------------------------

// Topology

// .ns3_proto.GlobalConfig globalConfig = 1;
inline bool Topology::_internal_has_globalconfig() const {
  return this != internal_default_instance() && _impl_.globalconfig_ != nullptr;
}
inline bool Topology::has_globalconfig() const {
  return _internal_has_globalconfig();
}
inline void Topology::clear_globalconfig() {
  if (GetArenaForAllocation() == nullptr && _impl_.globalconfig_ != nullptr) {
    delete _impl_.globalconfig_;
  }
  _impl_.globalconfig_ = nullptr;
}
inline const ::ns3_proto::GlobalConfig& Topology::_internal_globalconfig() const {
  const ::ns3_proto::GlobalConfig* p = _impl_.globalconfig_;
  return p != nullptr ? *p : reinterpret_cast<const ::ns3_proto::GlobalConfig&>(
      ::ns3_proto::_GlobalConfig_default_instance_);
}
inline const ::ns3_proto::GlobalConfig& Topology::globalconfig() const {
  // @@protoc_insertion_point(field_get:ns3_proto.Topology.globalConfig)
  return _internal_globalconfig();
}
inline void Topology::unsafe_arena_set_allocated_globalconfig(
    ::ns3_proto::GlobalConfig* globalconfig) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.globalconfig_);
  }
  _impl_.globalconfig_ = globalconfig;
  if (globalconfig) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ns3_proto.Topology.globalConfig)
}
inline ::ns3_proto::GlobalConfig* Topology::release_globalconfig() {
  
  ::ns3_proto::GlobalConfig* temp = _impl_.globalconfig_;
  _impl_.globalconfig_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ns3_proto::GlobalConfig* Topology::unsafe_arena_release_globalconfig() {
  // @@protoc_insertion_point(field_release:ns3_proto.Topology.globalConfig)
  
  ::ns3_proto::GlobalConfig* temp = _impl_.globalconfig_;
  _impl_.globalconfig_ = nullptr;
  return temp;
}
inline ::ns3_proto::GlobalConfig* Topology::_internal_mutable_globalconfig() {
  
  if (_impl_.globalconfig_ == nullptr) {
    auto* p = CreateMaybeMessage<::ns3_proto::GlobalConfig>(GetArenaForAllocation());
    _impl_.globalconfig_ = p;
  }
  return _impl_.globalconfig_;
}
inline ::ns3_proto::GlobalConfig* Topology::mutable_globalconfig() {
  ::ns3_proto::GlobalConfig* _msg = _internal_mutable_globalconfig();
  // @@protoc_insertion_point(field_mutable:ns3_proto.Topology.globalConfig)
  return _msg;
}
inline void Topology::set_allocated_globalconfig(::ns3_proto::GlobalConfig* globalconfig) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.globalconfig_;
  }
  if (globalconfig) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(globalconfig);
    if (message_arena != submessage_arena) {
      globalconfig = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, globalconfig, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.globalconfig_ = globalconfig;
  // @@protoc_insertion_point(field_set_allocated:ns3_proto.Topology.globalConfig)
}

// .ns3_proto.AllNodes nodes = 2;
inline bool Topology::_internal_has_nodes() const {
  return this != internal_default_instance() && _impl_.nodes_ != nullptr;
}
inline bool Topology::has_nodes() const {
  return _internal_has_nodes();
}
inline void Topology::clear_nodes() {
  if (GetArenaForAllocation() == nullptr && _impl_.nodes_ != nullptr) {
    delete _impl_.nodes_;
  }
  _impl_.nodes_ = nullptr;
}
inline const ::ns3_proto::AllNodes& Topology::_internal_nodes() const {
  const ::ns3_proto::AllNodes* p = _impl_.nodes_;
  return p != nullptr ? *p : reinterpret_cast<const ::ns3_proto::AllNodes&>(
      ::ns3_proto::_AllNodes_default_instance_);
}
inline const ::ns3_proto::AllNodes& Topology::nodes() const {
  // @@protoc_insertion_point(field_get:ns3_proto.Topology.nodes)
  return _internal_nodes();
}
inline void Topology::unsafe_arena_set_allocated_nodes(
    ::ns3_proto::AllNodes* nodes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nodes_);
  }
  _impl_.nodes_ = nodes;
  if (nodes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ns3_proto.Topology.nodes)
}
inline ::ns3_proto::AllNodes* Topology::release_nodes() {
  
  ::ns3_proto::AllNodes* temp = _impl_.nodes_;
  _impl_.nodes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ns3_proto::AllNodes* Topology::unsafe_arena_release_nodes() {
  // @@protoc_insertion_point(field_release:ns3_proto.Topology.nodes)
  
  ::ns3_proto::AllNodes* temp = _impl_.nodes_;
  _impl_.nodes_ = nullptr;
  return temp;
}
inline ::ns3_proto::AllNodes* Topology::_internal_mutable_nodes() {
  
  if (_impl_.nodes_ == nullptr) {
    auto* p = CreateMaybeMessage<::ns3_proto::AllNodes>(GetArenaForAllocation());
    _impl_.nodes_ = p;
  }
  return _impl_.nodes_;
}
inline ::ns3_proto::AllNodes* Topology::mutable_nodes() {
  ::ns3_proto::AllNodes* _msg = _internal_mutable_nodes();
  // @@protoc_insertion_point(field_mutable:ns3_proto.Topology.nodes)
  return _msg;
}
inline void Topology::set_allocated_nodes(::ns3_proto::AllNodes* nodes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.nodes_;
  }
  if (nodes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nodes);
    if (message_arena != submessage_arena) {
      nodes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nodes, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.nodes_ = nodes;
  // @@protoc_insertion_point(field_set_allocated:ns3_proto.Topology.nodes)
}

// repeated .ns3_proto.Link links = 3;
inline int Topology::_internal_links_size() const {
  return _impl_.links_.size();
}
inline int Topology::links_size() const {
  return _internal_links_size();
}
inline void Topology::clear_links() {
  _impl_.links_.Clear();
}
inline ::ns3_proto::Link* Topology::mutable_links(int index) {
  // @@protoc_insertion_point(field_mutable:ns3_proto.Topology.links)
  return _impl_.links_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ns3_proto::Link >*
Topology::mutable_links() {
  // @@protoc_insertion_point(field_mutable_list:ns3_proto.Topology.links)
  return &_impl_.links_;
}
inline const ::ns3_proto::Link& Topology::_internal_links(int index) const {
  return _impl_.links_.Get(index);
}
inline const ::ns3_proto::Link& Topology::links(int index) const {
  // @@protoc_insertion_point(field_get:ns3_proto.Topology.links)
  return _internal_links(index);
}
inline ::ns3_proto::Link* Topology::_internal_add_links() {
  return _impl_.links_.Add();
}
inline ::ns3_proto::Link* Topology::add_links() {
  ::ns3_proto::Link* _add = _internal_add_links();
  // @@protoc_insertion_point(field_add:ns3_proto.Topology.links)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ns3_proto::Link >&
Topology::links() const {
  // @@protoc_insertion_point(field_list:ns3_proto.Topology.links)
  return _impl_.links_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ns3_proto

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_topology_2eproto
